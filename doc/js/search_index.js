var search_data = {"index":{"searchIndex":["baclava","reader","writer","document","data","processor","reader","report","enactor","client","couldnotcreateerror","notcompleteerror","status","tavernaserviceerror","scufl","coordination","dot","link","model","parser","processor","processorlinks","sink","source","workflowdescription","tcclient","==()","add_processor()","all_links()","all_processors()","all_sinks()","all_sources()","beanshells()","create_data_doc()","create_data_map()","create_job_doc()","create_report()","eql?()","execute_sync()","finished?()","finished?()","from_document()","from_xml()","get_capabilities_doc()","get_element()","get_job_created_date()","get_job_modified_date()","get_job_outputs()","get_job_outputs_doc()","get_job_outputs_size()","get_job_outputs_url()","get_job_report()","get_job_status()","get_list()","get_metadata()","get_processor_links()","get_user_collection_url()","get_user_doc()","get_user_url()","get_xml_doc()","get_xml_doc_size()","is_processor?()","local_workers()","new()","new()","new()","new()","new()","new()","new()","parse()","parse_data_doc()","read()","read()","service_valid?()","setup()","submit_job()","submit_job_doc()","test_connect()","test_create_data()","test_create_job()","test_execute()","test_execute_with_data()","test_execute_with_multiple_data()","test_finished()","test_get_job_created_date()","test_get_job_modified_date()","test_get_job_status()","test_get_user_collection_url()","test_get_user_url()","test_job_outputs_size()","test_service_valid()","test_submit_job()","test_submit_job_with_data()","test_upload_data()","test_upload_workflow()","test_wait_for_job()","test_workflow_exists()","upload_data()","upload_data_doc()","upload_to_collection()","upload_workflow()","url_valid?()","valid?()","wait_for_job()","web_services()","workflow_exists?()","write()","write_data()","write_doc()","write_dot()","write_item_list()","write_list()","changelog","licence","readme"],"longSearchIndex":["baclava","baclava::reader","baclava::writer","document","document::data","document::processor","document::reader","document::report","enactor","enactor::client","enactor::couldnotcreateerror","enactor::notcompleteerror","enactor::status","enactor::tavernaserviceerror","scufl","scufl::coordination","scufl::dot","scufl::link","scufl::model","scufl::parser","scufl::processor","scufl::processorlinks","scufl::sink","scufl::source","scufl::workflowdescription","tcclient","document::data#==()","document::reader::add_processor()","scufl::model#all_links()","scufl::model#all_processors()","scufl::model#all_sinks()","scufl::model#all_sources()","scufl::model#beanshells()","enactor::client#create_data_doc()","baclava::reader::create_data_map()","enactor::client#create_job_doc()","document::reader::create_report()","document::data#eql?()","enactor::client#execute_sync()","enactor::client#finished?()","enactor::status::finished?()","document::report::from_document()","document::report::from_xml()","enactor::client#get_capabilities_doc()","baclava::reader::get_element()","enactor::client#get_job_created_date()","enactor::client#get_job_modified_date()","enactor::client#get_job_outputs()","enactor::client#get_job_outputs_doc()","enactor::client#get_job_outputs_size()","enactor::client#get_job_outputs_url()","enactor::client#get_job_report()","enactor::client#get_job_status()","baclava::reader::get_list()","baclava::reader::get_metadata()","scufl::model#get_processor_links()","enactor::client#get_user_collection_url()","enactor::client#get_user_doc()","enactor::client#get_user_url()","enactor::client#get_xml_doc()","enactor::client#get_xml_doc_size()","scufl::dot::is_processor?()","scufl::model#local_workers()","document::data::new()","document::report::new()","enactor::client::new()","enactor::couldnotcreateerror::new()","enactor::notcompleteerror::new()","scufl::dot::new()","scufl::model::new()","scufl::parser#parse()","enactor::client#parse_data_doc()","baclava::reader::read()","document::reader::read()","enactor::client#service_valid?()","tcclient#setup()","enactor::client#submit_job()","enactor::client#submit_job_doc()","tcclient#test_connect()","tcclient#test_create_data()","tcclient#test_create_job()","tcclient#test_execute()","tcclient#test_execute_with_data()","tcclient#test_execute_with_multiple_data()","tcclient#test_finished()","tcclient#test_get_job_created_date()","tcclient#test_get_job_modified_date()","tcclient#test_get_job_status()","tcclient#test_get_user_collection_url()","tcclient#test_get_user_url()","tcclient#test_job_outputs_size()","tcclient#test_service_valid()","tcclient#test_submit_job()","tcclient#test_submit_job_with_data()","tcclient#test_upload_data()","tcclient#test_upload_workflow()","tcclient#test_wait_for_job()","tcclient#test_workflow_exists()","enactor::client#upload_data()","enactor::client#upload_data_doc()","enactor::client#upload_to_collection()","enactor::client#upload_workflow()","enactor::client#url_valid?()","enactor::status::valid?()","enactor::client#wait_for_job()","scufl::model#web_services()","enactor::client#workflow_exists?()","baclava::writer::write()","baclava::writer::write_data()","baclava::writer::write_doc()","scufl::dot#write_dot()","baclava::writer::write_item_list()","baclava::writer::write_list()","","",""],"info":[["Baclava","","Baclava.html","",""],["Baclava::Reader","","Baclava/Reader.html","",""],["Baclava::Writer","","Baclava/Writer.html","",""],["Document","","Document.html","",""],["Document::Data","","Document/Data.html","","<p>Input or output data\n<p>value - the data value or a (possibly nested) list of data values\n"],["Document::Processor","","Document/Processor.html","",""],["Document::Reader","","Document/Reader.html","",""],["Document::Report","","Document/Report.html","",""],["Enactor","","Enactor.html","",""],["Enactor::Client","","Enactor/Client.html","","<p>Client library for accessing a Taverna Remote execution service.\n<p>Since the service is a rest interface, …\n"],["Enactor::CouldNotCreateError","","Enactor/CouldNotCreateError.html","","<p>Could not create resource.\n"],["Enactor::NotCompleteError","","Enactor/NotCompleteError.html","","<p>Job did not complete.  Thrown by execute_sync()\n"],["Enactor::Status","","Enactor/Status.html","","<p>Status messages that can be returned from TavernaService.get_job_status().\n<p>If finished?(status) is true, …\n"],["Enactor::TavernaServiceError","","Enactor/TavernaServiceError.html","","<p>Base class for Taverna service errors.\n"],["Scufl","","Scufl.html","",""],["Scufl::Coordination","","Scufl/Coordination.html","","<p>This is a representation of the ‘Run after…’ function in Taverna\nwhere the selected processor or workflow …\n"],["Scufl::Dot","","Scufl/Dot.html","","<p>This class enables you to write the script will will be used by dot (which\nis part of GraphViz) to generate …\n"],["Scufl::Link","","Scufl/Link.html","","<p>This represents a connection between any of the following pair of entities:\n{processor -&gt; processor}, …\n"],["Scufl::Model","","Scufl/Model.html","","<p>The model for a given Taverna 1 workflow.\n"],["Scufl::Parser","","Scufl/Parser.html","",""],["Scufl::Processor","","Scufl/Processor.html","","<p>This is the (shim) object within the workflow.  This can be a beanshell, a\nwebservice, a workflow, etc… …\n"],["Scufl::ProcessorLinks","","Scufl/ProcessorLinks.html","","<p>This object is returned after invoking model.get_processor_links(processor)\n.  The object contains two …\n"],["Scufl::Sink","","Scufl/Sink.html","","<p>This is the start node of a Link.  Each sink has a name and a port which is\nseperated by a colon; “:”. …\n"],["Scufl::Source","","Scufl/Source.html","","<p>This is the start node of a Link.  Each source has a name and a port which\nis seperated by a colon; “:”. …\n"],["Scufl::WorkflowDescription","","Scufl/WorkflowDescription.html","","<p>This contains basic descriptive information about the workflow model.\n"],["TcClient","","TcClient.html","",""],["==","Document::Data","Document/Data.html#method-i-3D-3D","(other)",""],["add_processor","Document::Reader","Document/Reader.html#method-c-add_processor","(element, report)",""],["all_links","Scufl::Model","Scufl/Model.html#method-i-all_links","()","<p>Retrieve ALL the links WITHIN the given workflow model.\n"],["all_processors","Scufl::Model","Scufl/Model.html#method-i-all_processors","()","<p>Retrieve ALL processor objects WITHIN the given workflow model.\n"],["all_sinks","Scufl::Model","Scufl/Model.html#method-i-all_sinks","()","<p>Retrieve ALL the sinks(outputs) WITHIN the given workflow model.\n"],["all_sources","Scufl::Model","Scufl/Model.html#method-i-all_sources","()","<p>Retrieve ALL the sources(inputs) WITHIN the given workflow model.\n"],["beanshells","Scufl::Model","Scufl/Model.html#method-i-beanshells","()","<p>Retrieve ALL the beanshell processors WITHIN the given workflow model.\n"],["create_data_doc","Enactor::Client","Enactor/Client.html#method-i-create_data_doc","(hash)","<p>Create a data document to be uploaded with upload_data_doc().\n<p>Return the data document a REXML::Document …\n"],["create_data_map","Baclava::Reader","Baclava/Reader.html#method-c-create_data_map","(element)",""],["create_job_doc","Enactor::Client","Enactor/Client.html#method-i-create_job_doc","(workflow_url, inputs_url=nil)","<p>Create a job document for submission with submit_job().\n<p>Return the job document as XML.\n<p>workflow_url – …\n"],["create_report","Document::Reader","Document/Reader.html#method-c-create_report","(element)",""],["eql?","Document::Data","Document/Data.html#method-i-eql-3F","(other)",""],["execute_sync","Enactor::Client","Enactor/Client.html#method-i-execute_sync","(workflow_xml=nil, workflow_url=nil, inputs=nil, timeout=DEFAULT_TIMEOUT, refresh=DEFAULT_REFRESH)","<p>Execute a workflow and wait until it’s finished.\n<p>This will block until the workflow has been executed …\n"],["finished?","Enactor::Client","Enactor/Client.html#method-i-finished-3F","(job_url)","<p>Check if a job has finished in one way or another.\n<p>Note that the job might have finished unsuccessfully. …\n"],["finished?","Enactor::Status","Enactor/Status.html#method-c-finished-3F","(status)","<p>Return True if the status is a finished status.\n<p>This would normally include COMPLETE, CANCELLED, DESTROYED …\n"],["from_document","Document::Report","Document/Report.html#method-c-from_document","(document)",""],["from_xml","Document::Report","Document/Report.html#method-c-from_xml","(xml)",""],["get_capabilities_doc","Enactor::Client","Enactor/Client.html#method-i-get_capabilities_doc","()","<p>Get the capabilities document as a REXML::Document\n<p>This document contains the links to the main collections …\n"],["get_element","Baclava::Reader","Baclava/Reader.html#method-c-get_element","(element)",""],["get_job_created_date","Enactor::Client","Enactor/Client.html#method-i-get_job_created_date","(job_url)","<p>Get the date a previously submitted job was created.\n<p>Return the date as a Datetime object.\n<p>job_url –  …\n"],["get_job_modified_date","Enactor::Client","Enactor/Client.html#method-i-get_job_modified_date","(job_url)","<p>Get the date a previously submitted job was last modified.\n<p>Return the date as a Datetime object.\n<p>job_url …\n"],["get_job_outputs","Enactor::Client","Enactor/Client.html#method-i-get_job_outputs","(job_url)","<p>Get the outputs of a job.\n<p>Return the job outputs as a hash where the keys are strings,  matching the\nnames …\n"],["get_job_outputs_doc","Enactor::Client","Enactor/Client.html#method-i-get_job_outputs_doc","(job_url)","<p>Get the output document for a job.\n<p>Return the output document as an REXML::Document object, or None if …\n"],["get_job_outputs_size","Enactor::Client","Enactor/Client.html#method-i-get_job_outputs_size","(job_url)","<p>Get the size of the outputs of a job.\n<p>Return the size of the outputs of a job in kilobytes. If no outputs …\n"],["get_job_outputs_url","Enactor::Client","Enactor/Client.html#method-i-get_job_outputs_url","(job_url)","<p>Get the URL to the output document for a job.\n<p>It generally only makes sense to call this function if  …\n"],["get_job_report","Enactor::Client","Enactor/Client.html#method-i-get_job_report","(job_url)","<p>Get the job’s internal progress report. This might be available while the\njob is running.\n<p>Return the internal …\n"],["get_job_status","Enactor::Client","Enactor/Client.html#method-i-get_job_status","(job_url)","<p>Get the status of a previously submitted job.\n<p>Return the status as a string, one of the values from Status …\n"],["get_list","Baclava::Reader","Baclava/Reader.html#method-c-get_list","(element)",""],["get_metadata","Baclava::Reader","Baclava/Reader.html#method-c-get_metadata","(element)",""],["get_processor_links","Scufl::Model","Scufl/Model.html#method-i-get_processor_links","(processor)","<p>For the given dataflow, return the beanshells and/or services which  have\ndirect links to or from the …\n"],["get_user_collection_url","Enactor::Client","Enactor/Client.html#method-i-get_user_collection_url","(collection)","<p>Get the URL to a user-owned collection.\n<p>collectionType – The collection, either “workflows” …\n"],["get_user_doc","Enactor::Client","Enactor/Client.html#method-i-get_user_doc","()","<p>Get the user document as an REXML::Document object.\n<p>This document contains the links to the user owned …\n"],["get_user_url","Enactor::Client","Enactor/Client.html#method-i-get_user_url","()","<p>Get the URL for the current user’s home on the server.\n"],["get_xml_doc","Enactor::Client","Enactor/Client.html#method-i-get_xml_doc","(doc_url, mimeType=MIME_TYPES[:rest])","<p>Retrieve an XML document from the given URL.\n<p>Return the retrieved document as a REXML::Document.\n<p>url – …\n"],["get_xml_doc_size","Enactor::Client","Enactor/Client.html#method-i-get_xml_doc_size","(doc_url, mimeType=MIME_TYPES[:rest])","<p>Return the size of an XML document from the given URL without fetching the\ndocument.\n<p>Return the size of …\n"],["is_processor?","Scufl::Dot","Scufl/Dot.html#method-c-is_processor-3F","(processor_name)","<p>Returns true if the given name is a processor; false otherwise\n"],["local_workers","Scufl::Model","Scufl/Model.html#method-i-local_workers","()","<p>Retrieve ALL local workers WITHIN the workflow\n"],["new","Document::Data","Document/Data.html#method-c-new","(value=nil, annotation=nil)",""],["new","Document::Report","Document/Report.html#method-c-new","()",""],["new","Enactor::Client","Enactor/Client.html#method-c-new","(url, username, password)","<p>Construct a Taverna remote execution service client accessing the service\nat the given base URL.\n<p>Note …\n"],["new","Enactor::CouldNotCreateError","Enactor/CouldNotCreateError.html#method-c-new","(url)",""],["new","Enactor::NotCompleteError","Enactor/NotCompleteError.html#method-c-new","(job_url, status)",""],["new","Scufl::Dot","Scufl/Dot.html#method-c-new","()","<p>Creates a new dot object for interaction.\n"],["new","Scufl::Model","Scufl/Model.html#method-c-new","()","<p>Creates an empty model for a Taverna 1 workflow.\n"],["parse","Scufl::Parser","Scufl/Parser.html#method-i-parse","(scufl)","<p>Returns the model for the given t2flow_file. The method accepts objects of\nclasses File and String only. …\n"],["parse_data_doc","Enactor::Client","Enactor/Client.html#method-i-parse_data_doc","(xml_document)","<p>Parse a data document as returned from get_job_outputs_doc().\n<p>Return a hash where the keys are strings, …\n"],["read","Baclava::Reader","Baclava/Reader.html#method-c-read","(xml)","<p>Reads a baclava document amd returns a hash of Document::Data objects\n"],["read","Document::Reader","Document/Reader.html#method-c-read","(report)",""],["service_valid?","Enactor::Client","Enactor/Client.html#method-i-service_valid-3F","()","<p>Checks if the username and password is valid for the service\n"],["setup","TcClient","TcClient.html#method-i-setup","()",""],["submit_job","Enactor::Client","Enactor/Client.html#method-i-submit_job","(workflow_url, inputs_url=nil)","<p>Submit a job to be queued for execution on the server.\n<p>Return the URL to the created job resource.\n<p>workflow_url …\n"],["submit_job_doc","Enactor::Client","Enactor/Client.html#method-i-submit_job_doc","(job_document)","<p>Submit a job to be queued for execution on the server.\n<p>Return the URL to the job resource.\n<p>job_document …\n"],["test_connect","TcClient","TcClient.html#method-i-test_connect","()",""],["test_create_data","TcClient","TcClient.html#method-i-test_create_data","()",""],["test_create_job","TcClient","TcClient.html#method-i-test_create_job","()",""],["test_execute","TcClient","TcClient.html#method-i-test_execute","()",""],["test_execute_with_data","TcClient","TcClient.html#method-i-test_execute_with_data","()",""],["test_execute_with_multiple_data","TcClient","TcClient.html#method-i-test_execute_with_multiple_data","()",""],["test_finished","TcClient","TcClient.html#method-i-test_finished","()",""],["test_get_job_created_date","TcClient","TcClient.html#method-i-test_get_job_created_date","()",""],["test_get_job_modified_date","TcClient","TcClient.html#method-i-test_get_job_modified_date","()",""],["test_get_job_status","TcClient","TcClient.html#method-i-test_get_job_status","()",""],["test_get_user_collection_url","TcClient","TcClient.html#method-i-test_get_user_collection_url","()",""],["test_get_user_url","TcClient","TcClient.html#method-i-test_get_user_url","()",""],["test_job_outputs_size","TcClient","TcClient.html#method-i-test_job_outputs_size","()",""],["test_service_valid","TcClient","TcClient.html#method-i-test_service_valid","()",""],["test_submit_job","TcClient","TcClient.html#method-i-test_submit_job","()",""],["test_submit_job_with_data","TcClient","TcClient.html#method-i-test_submit_job_with_data","()",""],["test_upload_data","TcClient","TcClient.html#method-i-test_upload_data","()",""],["test_upload_workflow","TcClient","TcClient.html#method-i-test_upload_workflow","()",""],["test_wait_for_job","TcClient","TcClient.html#method-i-test_wait_for_job","()",""],["test_workflow_exists","TcClient","TcClient.html#method-i-test_workflow_exists","()",""],["upload_data","Enactor::Client","Enactor/Client.html#method-i-upload_data","(hash)","<p>Upload data to be used with submit_job().\n<p>Return the URL to the created data resource.\n<p>hash – A hash where …\n"],["upload_data_doc","Enactor::Client","Enactor/Client.html#method-i-upload_data_doc","(xml_document)","<p>Upload a data document to the current user’s collection.\n<p>Return the URL of the created data resource. …\n"],["upload_to_collection","Enactor::Client","Enactor/Client.html#method-i-upload_to_collection","(url, data, content_type)","<p>Upload data by POST-ing to given URL.\n<p>Return the URL of the created resource if the request succeeded …\n"],["upload_workflow","Enactor::Client","Enactor/Client.html#method-i-upload_workflow","(workflow_xml)","<p>Upload a workflow XML document to the current users’ collection.\n<p>Return the URL of the created workflow …\n"],["url_valid?","Enactor::Client","Enactor/Client.html#method-i-url_valid-3F","(url)","<p>Tests if the url is valid for this server\n"],["valid?","Enactor::Status","Enactor/Status.html#method-c-valid-3F","(status)","<p>Check if a string is a valid status.\n"],["wait_for_job","Enactor::Client","Enactor/Client.html#method-i-wait_for_job","(job_url, timeout=DEFAULT_TIMEOUT, refresh=DEFAULT_REFRESH)","<p>Wait (blocking) for a job to finish, or until a maximum timeout  has been\nreached.\n<p>Return the status of …\n"],["web_services","Scufl::Model","Scufl/Model.html#method-i-web_services","()","<p>Retrieve ALL processors of that are webservices WITHIN the model.\n"],["workflow_exists?","Enactor::Client","Enactor/Client.html#method-i-workflow_exists-3F","(workflow_url)","<p>Checks if the workflow exists on the server\n<p>workflow_url – The URL to a workflow previously uploaded …\n"],["write","Baclava::Writer","Baclava/Writer.html#method-c-write","(data_map)",""],["write_data","Baclava::Writer","Baclava/Writer.html#method-c-write_data","(xml, data, index = nil)","<p>def self.write_metadata(xml, metadata)\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">xml</span>.<span class=\"ruby-identifier\">s</span> :<span class=\"ruby-identifier\">metadata</span>, <span class=\"ruby-string\">'xmlns:s'</span> =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-string\">'http://org.embl.ebi.escience/xscufl/0.1alpha'</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["write_doc","Baclava::Writer","Baclava/Writer.html#method-c-write_doc","(data_map)",""],["write_dot","Scufl::Dot","Scufl/Dot.html#method-i-write_dot","(stream, model)","<p>Writes to the given stream (File, StringIO, etc) the script to generate the\nimage showing the internals …\n"],["write_item_list","Baclava::Writer","Baclava/Writer.html#method-c-write_item_list","(xml, list)",""],["write_list","Baclava::Writer","Baclava/Writer.html#method-c-write_list","(xml, list, index)",""],["ChangeLog","","ChangeLog_rdoc.html","","<p>Version 0.7.2\n<p>Released &mdash; Wednesday, October 10, 2012\n\n<p>Added Functionality\n"],["LICENCE","","LICENCE.html","","\n<pre>                  GNU LESSER GENERAL PUBLIC LICENSE\n                      Version 3, 29 June 2007\n\nCopyright ...</pre>\n"],["README","","README_rdoc.html","","<p>Taverna 1 Interaction Gem\n<p>Authors &mdash; Finn Bacall, Stian Soiland, David Withers, Emmanuel Tagarira\n<p>Version … &mdash; "]]}}