<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>class Enactor::Client - RDoc Documentation</title>

<link type="text/css" media="screen" href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../index.html">Home</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/enactor/client.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link">Object
  
</nav>

    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li><a href="#method-c-new">::new</a>
    
    <li><a href="#method-i-create_data_doc">#create_data_doc</a>
    
    <li><a href="#method-i-create_job_doc">#create_job_doc</a>
    
    <li><a href="#method-i-execute_sync">#execute_sync</a>
    
    <li><a href="#method-i-finished-3F">#finished?</a>
    
    <li><a href="#method-i-get_capabilities_doc">#get_capabilities_doc</a>
    
    <li><a href="#method-i-get_job_created_date">#get_job_created_date</a>
    
    <li><a href="#method-i-get_job_modified_date">#get_job_modified_date</a>
    
    <li><a href="#method-i-get_job_outputs">#get_job_outputs</a>
    
    <li><a href="#method-i-get_job_outputs_doc">#get_job_outputs_doc</a>
    
    <li><a href="#method-i-get_job_outputs_size">#get_job_outputs_size</a>
    
    <li><a href="#method-i-get_job_outputs_url">#get_job_outputs_url</a>
    
    <li><a href="#method-i-get_job_report">#get_job_report</a>
    
    <li><a href="#method-i-get_job_status">#get_job_status</a>
    
    <li><a href="#method-i-get_user_collection_url">#get_user_collection_url</a>
    
    <li><a href="#method-i-get_user_doc">#get_user_doc</a>
    
    <li><a href="#method-i-get_user_url">#get_user_url</a>
    
    <li><a href="#method-i-get_xml_doc">#get_xml_doc</a>
    
    <li><a href="#method-i-get_xml_doc_size">#get_xml_doc_size</a>
    
    <li><a href="#method-i-parse_data_doc">#parse_data_doc</a>
    
    <li><a href="#method-i-service_valid-3F">#service_valid?</a>
    
    <li><a href="#method-i-submit_job">#submit_job</a>
    
    <li><a href="#method-i-submit_job_doc">#submit_job_doc</a>
    
    <li><a href="#method-i-upload_data">#upload_data</a>
    
    <li><a href="#method-i-upload_data_doc">#upload_data_doc</a>
    
    <li><a href="#method-i-upload_to_collection">#upload_to_collection</a>
    
    <li><a href="#method-i-upload_workflow">#upload_workflow</a>
    
    <li><a href="#method-i-url_valid-3F">#url_valid?</a>
    
    <li><a href="#method-i-wait_for_job">#wait_for_job</a>
    
    <li><a href="#method-i-workflow_exists-3F">#workflow_exists?</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../ChangeLog_rdoc.html">ChangeLog</a>
  
    <li class="file"><a href="../LICENCE.html">LICENCE</a>
  
    <li class="file"><a href="../README_rdoc.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../Scufl.html">Scufl</a>
  
    <li><a href="../Scufl/Coordination.html">Scufl::Coordination</a>
  
    <li><a href="../Scufl/Dot.html">Scufl::Dot</a>
  
    <li><a href="../Scufl/Link.html">Scufl::Link</a>
  
    <li><a href="../Scufl/Model.html">Scufl::Model</a>
  
    <li><a href="../Scufl/Parser.html">Scufl::Parser</a>
  
    <li><a href="../Scufl/Processor.html">Scufl::Processor</a>
  
    <li><a href="../Scufl/ProcessorLinks.html">Scufl::ProcessorLinks</a>
  
    <li><a href="../Scufl/Sink.html">Scufl::Sink</a>
  
    <li><a href="../Scufl/Source.html">Scufl::Source</a>
  
    <li><a href="../Scufl/WorkflowDescription.html">Scufl::WorkflowDescription</a>
  
    <li><a href="../Enactor.html">Enactor</a>
  
    <li><a href="../Enactor/Client.html">Enactor::Client</a>
  
    <li><a href="../Enactor/CouldNotCreateError.html">Enactor::CouldNotCreateError</a>
  
    <li><a href="../Enactor/NotCompleteError.html">Enactor::NotCompleteError</a>
  
    <li><a href="../Enactor/Status.html">Enactor::Status</a>
  
    <li><a href="../Enactor/TavernaServiceError.html">Enactor::TavernaServiceError</a>
  
    <li><a href="../Document.html">Document</a>
  
    <li><a href="../Document/Data.html">Document::Data</a>
  
    <li><a href="../Document/Processor.html">Document::Processor</a>
  
    <li><a href="../Document/Reader.html">Document::Reader</a>
  
    <li><a href="../Document/Report.html">Document::Report</a>
  
    <li><a href="../Baclava.html">Baclava</a>
  
    <li><a href="../Baclava/Reader.html">Baclava::Reader</a>
  
    <li><a href="../Baclava/Writer.html">Baclava::Writer</a>
  
    <li><a href="../TcClient.html">TcClient</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class Enactor::Client</h1>

  <div id="description" class="description">
    
<p><a href="Client.html">Client</a> library for accessing a Taverna Remote
execution service.</p>

<p>Since the service is a rest interface, this library reflects that to  a
certain degree and many of the methods return URLs to be used by  other
methods.</p>

<pre>The main methods of interest are - in order of a normal execution:

   execute_sync() -- Given a scufl document or the URL for a previously 
       uploaded workflow, and data as a hash or URL for previously
       uploaded data, submit job for execution, wait for completion 
       (or a timeout) and retrieve results. This is a blocking 
       convenience method that can be used instead of the methods below.

   upload_workflow() -- Given a scufl document as a string, upload the
       workflow to the server for later execution. Return the URL for the
       created workflow resource that can be used with submit_job()

   upload_data()-- Given a hash of input values to a
       workflow run, upload the data to the user's collection.
       Return the URL for the created data resource that can be used with 
       submit_job()

   submit_job() -- Given the URL for a workflow resource and optionally
       the URL for a input data resource, submit the a to the server 
       to be executed. Return the URL to the created job resource.

   get_job_status() -- Get the status of the job. Return one of the values from
       Status.

   finished?() -- Return True if the job is in a finished state. Note 
       that this also includes failed states.

   wait_for_job() -- Wait until job has finished execution, or a maximum
       timeout is exceeded.

   get_job_outputs() -- Get the outputs produced by job.  Return a  
       hash which values are strings, lists of strings, 
       or deeper lists.</pre>

<p>Most or all of these methods might in addition to stated exceptions also
raise Net::HTTPError or InvalidResponseError if anything goes wrong in
communicating with the service.</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <!-- Constants -->
    <section id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt id="DEFAULT_REFRESH">DEFAULT_REFRESH
        
        <dd class="description">
        
      
        <dt id="DEFAULT_TIMEOUT">DEFAULT_TIMEOUT
        
        <dd class="description">
        
      
        <dt id="MIME_TYPES">MIME_TYPES
        
        <dd class="description"><p>Mime types used by the rest protocol.</p>

<pre>See net.sf.taverna.service.interfaces.TavernaConstants.java</pre>
        
      
        <dt id="NAMESPACES">NAMESPACES
        
        <dd class="description"><p>Name spaces used by various XML documents.</p>
        
      
      </dl>
    </section>
    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(url, username, password)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Construct a Taverna remote execution service client accessing the service
at the given base URL.</p>

<p>Note that this constructor will not attempt to verify the URL or the 
credentials. To verify, call <a
href="Client.html#method-i-get_user_url">#get_user_url</a>() which requires
authentication.</p>

<p>url – The base URL for the service, normally ending in /v1/, for example:</p>

<pre>&quot;http://myserver.com:8080/tavernaService/v1/&quot;</pre>

<p>username – The username of a user that has been previously created or</p>

<pre>registered in the web interface of the service.</pre>

<p>password – The password of the user. Note that the password will be sent</p>

<pre>over the wire using unencrypted HTTP Basic Auth, unless the URL starts
  with &quot;https&quot;.</pre>
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">url</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">password</span>)
        <span class="ruby-ivar">@url</span> = <span class="ruby-identifier">url</span>
        <span class="ruby-ivar">@username</span> = <span class="ruby-identifier">username</span>
        <span class="ruby-ivar">@password</span> = <span class="ruby-identifier">password</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- new-source -->
          
        </div>

        

        
      </div><!-- new-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-create_data_doc" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">create_data_doc</span><span
            class="method-args">(hash)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Create a data document to be uploaded with <a
href="Client.html#method-i-upload_data_doc">#upload_data_doc</a>().</p>

<p>Return the data document a REXML::Document. This data document can be
parsed using <a
href="Client.html#method-i-parse_data_doc">#parse_data_doc</a>()</p>

<p>hash – A hash where the keys are strings, matching the names of input</p>

<pre>ports of the workflow to run. The values are Document::Data objects.</pre>
          

          
          <div class="method-source-code" id="create_data_doc-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">create_data_doc</span>(<span class="ruby-identifier">hash</span>)
        <span class="ruby-constant">Baclava</span><span class="ruby-operator">::</span><span class="ruby-constant">Writer</span>.<span class="ruby-identifier">write_doc</span>(<span class="ruby-identifier">hash</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- create_data_doc-source -->
          
        </div>

        

        
      </div><!-- create_data_doc-method -->

    
      <div id="method-i-create_job_doc" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">create_job_doc</span><span
            class="method-args">(workflow_url, inputs_url=nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Create a job document for submission with <a
href="Client.html#method-i-submit_job">#submit_job</a>().</p>

<p>Return the job document as XML.</p>

<p>workflow_url – The URL of a workflow previously uploaded using</p>

<pre>upload_workflow()</pre>

<p>inputs_url – The (optional) URL of a input document previously</p>

<pre>uploaded using upload_data_doc()</pre>
          

          
          <div class="method-source-code" id="create_job_doc-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 402</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">create_job_doc</span>(<span class="ruby-identifier">workflow_url</span>, <span class="ruby-identifier">inputs_url</span>=<span class="ruby-keyword">nil</span>)
        <span class="ruby-identifier">xml</span> = <span class="ruby-constant">Builder</span><span class="ruby-operator">::</span><span class="ruby-constant">XmlMarkup</span>.<span class="ruby-identifier">new</span>
        <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">instruct!</span>
        <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">xml</span>.<span class="ruby-identifier">job</span>(<span class="ruby-string">'xmlns'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">NAMESPACES</span>[<span class="ruby-value">:service</span>], <span class="ruby-string">'xmlns:xlink'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">NAMESPACES</span>[<span class="ruby-value">:xlink</span>]) {
                <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">inputs</span>(<span class="ruby-string">'xlink:href'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">inputs_url</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">inputs_url</span>
                <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">workflow</span>(<span class="ruby-string">'xlink:href'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">workflow_url</span>)
        })
<span class="ruby-keyword">end</span></pre>
          </div><!-- create_job_doc-source -->
          
        </div>

        

        
      </div><!-- create_job_doc-method -->

    
      <div id="method-i-execute_sync" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">execute_sync</span><span
            class="method-args">(workflow_xml=nil, workflow_url=nil, inputs=nil, timeout=DEFAULT_TIMEOUT, refresh=DEFAULT_REFRESH)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Execute a workflow and wait until it’s finished.</p>

<p>This will block until the workflow has been executed by the server, and
return the result of the workflow run.</p>

<p>Return the parsed output document as a hash where the keys are  strings,
matching the names of output ports of the workflow. The  values are <a
href="../Document/Data.html">Document::Data</a> objects. If the workflow
did not produce any output, nil might be returned instead.</p>

<p>workflow_xml – The workflow as a Taverna scufl XML string. This
<strong>or</strong> the</p>

<pre>workflow_url parameter is required.</pre>

<p>workflow_url – The URL to a workflow previously uploaded using</p>

<pre>upload_workflow(). This *or* the workflow_xml parameter is required.</pre>

<p>inputs – The (optional) inputs to the workflow, either as a <a
href="../Baclava.html">Baclava</a></p>

<pre>XML document (string), or as a hash where the keys are 
strings, matching the names of input ports of the workflow. The 
values can be strings, lists of strings, or deeper lists.</pre>

<p>timeout – The maximum number of seconds (as a float) to wait for job.</p>

<pre>The default value is DEFAULT_TIMEOUT.</pre>

<p>refresh – In seconds (as a float), how often to check the job’s</p>

<pre>status while waiting. The default value is DEFAULT_REFRESH.</pre>

<p>Raises:</p>

<pre>NotCompleteError -- If the job did not complete, for instance because
        the timeout was reached before completion.

urllib2.HTTPError -- If any step in submitting or requesting the status and
        result of the job failed.</pre>
          

          
          <div class="method-source-code" id="execute_sync-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 654</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">execute_sync</span>(<span class="ruby-identifier">workflow_xml</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">workflow_url</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">inputs</span>=<span class="ruby-keyword">nil</span>, 
                                <span class="ruby-identifier">timeout</span>=<span class="ruby-constant">DEFAULT_TIMEOUT</span>, <span class="ruby-identifier">refresh</span>=<span class="ruby-constant">DEFAULT_REFRESH</span>)
        <span class="ruby-identifier">raise</span> <span class="ruby-constant">TypeError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;workflow_xml or worklowURL must be given&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">workflow_xml</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">workflow_url</span> 
        <span class="ruby-identifier">raise</span> <span class="ruby-constant">TypeError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;Only one of workflow_xml and workflow_url can be given&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">workflow_xml</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">workflow_url</span>
         
        <span class="ruby-identifier">workflow_url</span> = <span class="ruby-identifier">upload_workflow</span>(<span class="ruby-identifier">workflow_xml</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">workflow_xml</span>
        <span class="ruby-identifier">inputs_url</span> = <span class="ruby-identifier">upload_data</span>(<span class="ruby-identifier">inputs</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">inputs</span>
        
        <span class="ruby-identifier">job_url</span> = <span class="ruby-identifier">submit_job</span>(<span class="ruby-identifier">workflow_url</span>, <span class="ruby-identifier">inputs_url</span>)
        <span class="ruby-identifier">status</span> = <span class="ruby-identifier">wait_for_job</span>(<span class="ruby-identifier">job_url</span>, <span class="ruby-identifier">timeout</span>, <span class="ruby-identifier">refresh</span>)

        <span class="ruby-identifier">raise</span> <span class="ruby-constant">NotCompleteError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">job_url</span>, <span class="ruby-identifier">status</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">status</span> <span class="ruby-operator">!=</span> <span class="ruby-constant">Status</span><span class="ruby-operator">::</span><span class="ruby-constant">COMPLETE</span>
        
        <span class="ruby-identifier">get_job_outputs</span>(<span class="ruby-identifier">job_url</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- execute_sync-source -->
          
        </div>

        

        
      </div><!-- execute_sync-method -->

    
      <div id="method-i-finished-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">finished?</span><span
            class="method-args">(job_url)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Check if a job has finished in one way or another.</p>

<p>Note that the job might have finished unsuccessfully. To check</p>
<dl class="rdoc-list note-list"><dt>if a job is actually complete, check
<dd>
<p><a href="Client.html#method-i-get_job_status">#get_job_status</a>(job_url)
== Status::COMPLETE.</p>
</dd></dl>

<p>Return True if the job is in a finished state, that is that the <a
href="Status.html#method-c-finished-3F">Enactor::Status.finished?</a>(<a
href="Client.html#method-i-get_job_status">#get_job_status</a>()) is True.</p>

<p>job_url – The URL to a job resource previously created using</p>

<pre>#submit_job().</pre>
          

          
          <div class="method-source-code" id="finished-3F-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 525</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">finished?</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-identifier">status</span> = <span class="ruby-identifier">get_job_status</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-constant">Status</span>.<span class="ruby-identifier">finished?</span>(<span class="ruby-identifier">status</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- finished-3F-source -->
          
        </div>

        

        
      </div><!-- finished-3F-method -->

    
      <div id="method-i-get_capabilities_doc" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_capabilities_doc</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Get the capabilities document as a REXML::Document</p>

<p>This document contains the links to the main collections of the service.</p>
          

          
          <div class="method-source-code" id="get_capabilities_doc-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_capabilities_doc</span>
        <span class="ruby-identifier">url</span> = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-ivar">@url</span>)
        <span class="ruby-identifier">request</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">Get</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">path</span>)
        <span class="ruby-identifier">request</span>[<span class="ruby-string">'Accept'</span>] = <span class="ruby-constant">MIME_TYPES</span>[<span class="ruby-value">:rest</span>]
        <span class="ruby-identifier">request</span>.<span class="ruby-identifier">basic_auth</span> <span class="ruby-ivar">@username</span>, <span class="ruby-ivar">@password</span>
        <span class="ruby-identifier">response</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">start</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">host</span>, <span class="ruby-identifier">url</span>.<span class="ruby-identifier">port</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request</span>(<span class="ruby-identifier">request</span>)
        }
        <span class="ruby-identifier">response</span>.<span class="ruby-identifier">value</span>
        <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">response</span>.<span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_capabilities_doc-source -->
          
        </div>

        

        
      </div><!-- get_capabilities_doc-method -->

    
      <div id="method-i-get_job_created_date" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_job_created_date</span><span
            class="method-args">(job_url)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Get the date a previously submitted job was created.</p>

<p>Return the date as a Datetime object.</p>

<p>job_url – The URL to a job resource previously created using</p>

<pre>submit_job().</pre>
          

          
          <div class="method-source-code" id="get_job_created_date-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 449</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_job_created_date</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-identifier">job_document</span> = <span class="ruby-identifier">get_xml_doc</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-comment">#created = job_document.elements[&quot;{#{NAMESPACES[:dcterms]}}created&quot;]</span>
        <span class="ruby-identifier">created</span> = <span class="ruby-identifier">job_document</span>.<span class="ruby-identifier">root</span>.<span class="ruby-identifier">elements</span>[<span class="ruby-string">'dcterms:created'</span>].<span class="ruby-identifier">text</span>
        <span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">created</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_job_created_date-source -->
          
        </div>

        

        
      </div><!-- get_job_created_date-method -->

    
      <div id="method-i-get_job_modified_date" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_job_modified_date</span><span
            class="method-args">(job_url)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Get the date a previously submitted job was last modified.</p>

<p>Return the date as a Datetime object.</p>

<p>job_url – The URL to a job resource previously created using</p>

<pre>submit_job().</pre>
          

          
          <div class="method-source-code" id="get_job_modified_date-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 462</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_job_modified_date</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-identifier">job_document</span> = <span class="ruby-identifier">get_xml_doc</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-comment">#modified = job_document.elements[&quot;{#{NAMESPACES[:dcterms]}}modified&quot;]</span>
        <span class="ruby-identifier">modified</span> = <span class="ruby-identifier">job_document</span>.<span class="ruby-identifier">root</span>.<span class="ruby-identifier">elements</span>[<span class="ruby-string">'dcterms:modified'</span>].<span class="ruby-identifier">text</span>
        <span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">modified</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_job_modified_date-source -->
          
        </div>

        

        
      </div><!-- get_job_modified_date-method -->

    
      <div id="method-i-get_job_outputs" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_job_outputs</span><span
            class="method-args">(job_url)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Get the outputs of a job.</p>

<p>Return the job outputs as a hash where the keys are strings,  matching the
names of output ports of the workflow. The values are <a
href="../Document/Data.html">Document::Data</a> objects. If no outputs
exists, nil is returned instead.</p>

<p>job_url – The URL to a job resource previously created using</p>

<pre>submit_job().</pre>
          

          
          <div class="method-source-code" id="get_job_outputs-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 493</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_job_outputs</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-identifier">job_outputs</span> = <span class="ruby-identifier">get_job_outputs_doc</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">job_outputs</span>
        <span class="ruby-identifier">parse_data_doc</span>(<span class="ruby-identifier">job_outputs</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_job_outputs-source -->
          
        </div>

        

        
      </div><!-- get_job_outputs-method -->

    
      <div id="method-i-get_job_outputs_doc" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_job_outputs_doc</span><span
            class="method-args">(job_url)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Get the output document for a job.</p>

<p>Return the output document as an REXML::Document object, or None if the job
didn’t have an output document (yet). This document can be parsed using
<a href="Client.html#method-i-parse_data_doc">#parse_data_doc</a>().</p>

<p>job_url – The URL to a job resource previously created using</p>

<pre>submit_job().</pre>
          

          
          <div class="method-source-code" id="get_job_outputs_doc-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 263</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_job_outputs_doc</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-identifier">outputs_url</span> = <span class="ruby-identifier">get_job_outputs_url</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">outputs_url</span>
        <span class="ruby-identifier">get_xml_doc</span>(<span class="ruby-identifier">outputs_url</span>, <span class="ruby-constant">MIME_TYPES</span>[<span class="ruby-value">:baclava</span>])
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_job_outputs_doc-source -->
          
        </div>

        

        
      </div><!-- get_job_outputs_doc-method -->

    
      <div id="method-i-get_job_outputs_size" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_job_outputs_size</span><span
            class="method-args">(job_url)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Get the size of the outputs of a job.</p>

<p>Return the size of the outputs of a job in kilobytes. If no outputs exists,
nil is returned instead.</p>

<p>job_url – The URL to a job resource previously created using</p>

<pre>submit_job().</pre>
          

          
          <div class="method-source-code" id="get_job_outputs_size-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 506</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_job_outputs_size</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-identifier">outputs_url</span> = <span class="ruby-identifier">get_job_outputs_url</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">outputs_url</span>
        <span class="ruby-identifier">get_xml_doc_size</span>(<span class="ruby-identifier">outputs_url</span>, <span class="ruby-constant">MIME_TYPES</span>[<span class="ruby-value">:baclava</span>])
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_job_outputs_size-source -->
          
        </div>

        

        
      </div><!-- get_job_outputs_size-method -->

    
      <div id="method-i-get_job_outputs_url" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_job_outputs_url</span><span
            class="method-args">(job_url)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Get the URL to the output document for a job.</p>

<p>It generally only makes sense to call this function if <a
href="Client.html#method-i-get_job_status">#get_job_status</a>() ==
Status::COMPLETED, but no check is enforced here.</p>

<p>Return the URL to a data document produced by the job, or None if the job
has not (yet) produced any output.</p>

<p>job_url – The URL to a job resource previously created using</p>

<pre>submit_job().</pre>
          

          
          <div class="method-source-code" id="get_job_outputs_url-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 247</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_job_outputs_url</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-identifier">job_document</span> = <span class="ruby-identifier">get_xml_doc</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-comment">#outputs_element = job_document.root.elements[&quot;{#{NAMESPACES[:service]}}outputs&quot;]</span>
        <span class="ruby-identifier">outputs_element</span> = <span class="ruby-identifier">job_document</span>.<span class="ruby-identifier">root</span>.<span class="ruby-identifier">elements</span>[<span class="ruby-string">'outputs'</span>]
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">outputs_element</span>
        <span class="ruby-identifier">outputs_element</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">get_attribute_ns</span>(<span class="ruby-constant">NAMESPACES</span>[<span class="ruby-value">:xlink</span>], <span class="ruby-string">'href'</span>).<span class="ruby-identifier">value</span> 
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_job_outputs_url-source -->
          
        </div>

        

        
      </div><!-- get_job_outputs_url-method -->

    
      <div id="method-i-get_job_report" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_job_report</span><span
            class="method-args">(job_url)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Get the job’s internal progress report. This might be available while the
job is running.</p>

<p>Return the internal progress report as a <a
href="../Document/Report.html">Document::Report</a> object.</p>

<p>job_url – The URL to a job resource previously created using <a
href="Client.html#method-i-submit_job">#submit_job</a>().</p>
          

          
          <div class="method-source-code" id="get_job_report-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 475</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_job_report</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-identifier">job_document</span> = <span class="ruby-identifier">get_xml_doc</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-comment">#report_element = job_document.elements[&quot;{#{NAMESPACES[:service]}}report&quot;]</span>
        <span class="ruby-identifier">report_element</span> = <span class="ruby-identifier">job_document</span>.<span class="ruby-identifier">root</span>.<span class="ruby-identifier">elements</span>[<span class="ruby-string">'report'</span>]
        <span class="ruby-identifier">report_url</span> = <span class="ruby-identifier">report_element</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">get_attribute_ns</span>(<span class="ruby-constant">NAMESPACES</span>[<span class="ruby-value">:xlink</span>], <span class="ruby-string">'href'</span>).<span class="ruby-identifier">value</span>
        <span class="ruby-comment"># TODO: Cache report_url per job</span>
        <span class="ruby-identifier">job_report_document</span> = <span class="ruby-identifier">get_xml_doc</span>(<span class="ruby-identifier">report_url</span>, <span class="ruby-constant">MIME_TYPES</span>[<span class="ruby-value">:report</span>])
        <span class="ruby-constant">Document</span><span class="ruby-operator">::</span><span class="ruby-constant">Report</span>.<span class="ruby-identifier">from_document</span>(<span class="ruby-identifier">job_report_document</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_job_report-source -->
          
        </div>

        

        
      </div><!-- get_job_report-method -->

    
      <div id="method-i-get_job_status" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_job_status</span><span
            class="method-args">(job_url)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Get the status of a previously submitted job.</p>

<p>Return the status as a string, one of the values from <a
href="Status.html">Status</a>.</p>

<p>job_url – The URL to a job resource previously created using</p>

<pre>submit_job().</pre>
          

          
          <div class="method-source-code" id="get_job_status-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 434</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_job_status</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-identifier">job_document</span> = <span class="ruby-identifier">get_xml_doc</span>(<span class="ruby-identifier">job_url</span>)
        <span class="ruby-comment">#status = job_document.elements[&quot;{#{NAMESPACES[:service]}}status&quot;]</span>
        <span class="ruby-identifier">status</span> = <span class="ruby-identifier">job_document</span>.<span class="ruby-identifier">root</span>.<span class="ruby-identifier">elements</span>[<span class="ruby-string">'status'</span>]
        <span class="ruby-comment"># TODO: For future checks, use: </span>
        <span class="ruby-comment">#status_url = status.attributes.get_attribute_ns(NAMESPACES[:xlink], 'href').value</span>
        <span class="ruby-identifier">status</span>.<span class="ruby-identifier">text</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_job_status-source -->
          
        </div>

        

        
      </div><!-- get_job_status-method -->

    
      <div id="method-i-get_user_collection_url" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_user_collection_url</span><span
            class="method-args">(collection)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Get the URL to a user-owned collection.</p>

<p>collectionType – The collection, either “workflows” or “datas”</p>
          

          
          <div class="method-source-code" id="get_user_collection_url-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_user_collection_url</span>(<span class="ruby-identifier">collection</span>)
        <span class="ruby-identifier">user_doc</span> = <span class="ruby-identifier">get_user_doc</span>()

        <span class="ruby-comment">#collections = user_doc.root.elements[&quot;{#{NAMESPACES[:service]}}#{collection}&quot;]</span>
        <span class="ruby-identifier">collections</span> = <span class="ruby-identifier">user_doc</span>.<span class="ruby-identifier">root</span>.<span class="ruby-identifier">elements</span>[<span class="ruby-identifier">collection</span>]
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">collections</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">get_attribute_ns</span>(<span class="ruby-constant">NAMESPACES</span>[<span class="ruby-value">:xlink</span>], <span class="ruby-string">'href'</span>).<span class="ruby-identifier">value</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_user_collection_url-source -->
          
        </div>

        

        
      </div><!-- get_user_collection_url-method -->

    
      <div id="method-i-get_user_doc" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_user_doc</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Get the user document as an REXML::Document object.</p>

<p>This document contains the links to the user owned collections,  such as
where to upload workflows and jobs.</p>
          

          
          <div class="method-source-code" id="get_user_doc-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_user_doc</span>
        <span class="ruby-identifier">url</span> = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">get_user_url</span>())
        <span class="ruby-identifier">request</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">Get</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">path</span>)
        <span class="ruby-identifier">request</span>[<span class="ruby-string">'Accept'</span>] = <span class="ruby-constant">MIME_TYPES</span>[<span class="ruby-value">:rest</span>]
        <span class="ruby-identifier">request</span>.<span class="ruby-identifier">basic_auth</span> <span class="ruby-ivar">@username</span>, <span class="ruby-ivar">@password</span>
        <span class="ruby-identifier">response</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">start</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">host</span>, <span class="ruby-identifier">url</span>.<span class="ruby-identifier">port</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
                <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request</span>(<span class="ruby-identifier">request</span>)
        }
        <span class="ruby-identifier">response</span>.<span class="ruby-identifier">value</span>
        <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">response</span>.<span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_user_doc-source -->
          
        </div>

        

        
      </div><!-- get_user_doc-method -->

    
      <div id="method-i-get_user_url" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_user_url</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Get the URL for the current user’s home on the server.</p>
          

          
          <div class="method-source-code" id="get_user_url-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_user_url</span>
        <span class="ruby-identifier">capabilities_doc</span> = <span class="ruby-identifier">get_capabilities_doc</span>()
        <span class="ruby-comment">#currentUser = capabilities_doc.root.elements[&quot;{#{NAMESPACES[:service]}}currentUser&quot;]</span>
        <span class="ruby-identifier">current_user</span> = <span class="ruby-identifier">capabilities_doc</span>.<span class="ruby-identifier">root</span>.<span class="ruby-identifier">elements</span>[<span class="ruby-string">'currentUser'</span>]
        <span class="ruby-identifier">current_user_url</span> = <span class="ruby-identifier">current_user</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">get_attribute_ns</span>(<span class="ruby-constant">NAMESPACES</span>[<span class="ruby-value">:xlink</span>], <span class="ruby-string">'href'</span>).<span class="ruby-identifier">value</span>
        
        <span class="ruby-identifier">url</span> = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">current_user_url</span>)
        <span class="ruby-identifier">request</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">Get</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">path</span>)
        <span class="ruby-identifier">request</span>[<span class="ruby-string">'Accept'</span>] = <span class="ruby-constant">MIME_TYPES</span>[<span class="ruby-value">:rest</span>]
        <span class="ruby-identifier">request</span>.<span class="ruby-identifier">basic_auth</span> <span class="ruby-ivar">@username</span>, <span class="ruby-ivar">@password</span>
        <span class="ruby-identifier">response</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">start</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">host</span>, <span class="ruby-identifier">url</span>.<span class="ruby-identifier">port</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
                <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request</span>(<span class="ruby-identifier">request</span>)
        }
        <span class="ruby-identifier">response</span>.<span class="ruby-identifier">error!</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTPSuccess</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTPRedirection</span>)
        <span class="ruby-identifier">response</span>.<span class="ruby-identifier">header</span>[<span class="ruby-string">'Location'</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_user_url-source -->
          
        </div>

        

        
      </div><!-- get_user_url-method -->

    
      <div id="method-i-get_xml_doc" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_xml_doc</span><span
            class="method-args">(doc_url, mimeType=MIME_TYPES[:rest])</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Retrieve an XML document from the given URL.</p>

<p>Return the retrieved document as a REXML::Document.</p>

<p>url – The URL to a resource retrievable as an XML document</p>

<p>mimeType – The mime-type to request using the Accept header, by default</p>

<pre>MIME_TYPES[:rest]</pre>
          

          
          <div class="method-source-code" id="get_xml_doc-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 277</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_xml_doc</span>(<span class="ruby-identifier">doc_url</span>, <span class="ruby-identifier">mimeType</span>=<span class="ruby-constant">MIME_TYPES</span>[<span class="ruby-value">:rest</span>])
        <span class="ruby-identifier">url</span> = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">doc_url</span>)                     
        <span class="ruby-identifier">request</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">Get</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">path</span>)
        <span class="ruby-identifier">request</span>[<span class="ruby-string">'Accept'</span>] = <span class="ruby-identifier">mimeType</span>
        <span class="ruby-identifier">request</span>.<span class="ruby-identifier">basic_auth</span> <span class="ruby-ivar">@username</span>, <span class="ruby-ivar">@password</span>
        <span class="ruby-identifier">response</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">start</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">host</span>, <span class="ruby-identifier">url</span>.<span class="ruby-identifier">port</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request</span>(<span class="ruby-identifier">request</span>)
        }
        <span class="ruby-identifier">response</span>.<span class="ruby-identifier">value</span>
        <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">response</span>.<span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_xml_doc-source -->
          
        </div>

        

        
      </div><!-- get_xml_doc-method -->

    
      <div id="method-i-get_xml_doc_size" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_xml_doc_size</span><span
            class="method-args">(doc_url, mimeType=MIME_TYPES[:rest])</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Return the size of an XML document from the given URL without fetching the
document.</p>

<p>Return the size of a XML document .</p>

<p>url – The URL to a resource find the size of</p>

<p>mimeType – The mime-type to request using the Accept header, by default</p>

<pre>MIME_TYPES[:rest]</pre>
          

          
          <div class="method-source-code" id="get_xml_doc_size-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 298</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_xml_doc_size</span>(<span class="ruby-identifier">doc_url</span>, <span class="ruby-identifier">mimeType</span>=<span class="ruby-constant">MIME_TYPES</span>[<span class="ruby-value">:rest</span>])
        <span class="ruby-identifier">url</span> = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">doc_url</span>)                     
        <span class="ruby-identifier">request</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">Head</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">path</span>)
        <span class="ruby-identifier">request</span>[<span class="ruby-string">'Accept'</span>] = <span class="ruby-identifier">mimeType</span>
        <span class="ruby-identifier">request</span>.<span class="ruby-identifier">basic_auth</span> <span class="ruby-ivar">@username</span>, <span class="ruby-ivar">@password</span>
        <span class="ruby-identifier">response</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">start</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">host</span>, <span class="ruby-identifier">url</span>.<span class="ruby-identifier">port</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request</span>(<span class="ruby-identifier">request</span>)
        }
        <span class="ruby-identifier">response</span>.<span class="ruby-identifier">content_length</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_xml_doc_size-source -->
          
        </div>

        

        
      </div><!-- get_xml_doc_size-method -->

    
      <div id="method-i-parse_data_doc" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_data_doc</span><span
            class="method-args">(xml_document)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Parse a data document as returned from <a
href="Client.html#method-i-get_job_outputs_doc">#get_job_outputs_doc</a>().</p>

<p>Return a hash where the keys are strings, matching the names of</p>

<pre>ports of the workflow. The values are Document::Data objects.</pre>

<p>xml – A data document as a REXML::Document. This data document can be
created</p>

<pre>using create_data_doc()</pre>
          

          
          <div class="method-source-code" id="parse_data_doc-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 316</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">parse_data_doc</span>(<span class="ruby-identifier">xml_document</span>)
        <span class="ruby-constant">Baclava</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">read</span>(<span class="ruby-identifier">xml_document</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_data_doc-source -->
          
        </div>

        

        
      </div><!-- parse_data_doc-method -->

    
      <div id="method-i-service_valid-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">service_valid?</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Checks if the username and password is valid for the service</p>
          

          
          <div class="method-source-code" id="service_valid-3F-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 574</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">service_valid?</span>
        <span class="ruby-keyword">begin</span>
                <span class="ruby-identifier">get_user_url</span>
                <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">rescue</span>
                <span class="ruby-keyword">false</span>
        <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- service_valid-3F-source -->
          
        </div>

        

        
      </div><!-- service_valid-3F-method -->

    
      <div id="method-i-submit_job" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">submit_job</span><span
            class="method-args">(workflow_url, inputs_url=nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Submit a job to be queued for execution on the server.</p>

<p>Return the URL to the created job resource.</p>

<p>workflow_url – The URL of a workflow previously uploaded using</p>

<pre>upload_workflow()</pre>

<p>inputs_url – The (optional) URL of a input resource previously</p>

<pre>uploaded using upload_data()</pre>

<p>Raises:</p>

<pre>CouldNotCreateError -- If the service returned 200 OK instead of
    creating the resource</pre>
          

          
          <div class="method-source-code" id="submit_job-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 544</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">submit_job</span>(<span class="ruby-identifier">workflow_url</span>, <span class="ruby-identifier">inputs_url</span>=<span class="ruby-keyword">nil</span>)
        <span class="ruby-identifier">job_document</span> = <span class="ruby-identifier">create_job_doc</span>(<span class="ruby-identifier">workflow_url</span>, <span class="ruby-identifier">inputs_url</span>)
        <span class="ruby-identifier">submit_job_doc</span>(<span class="ruby-identifier">job_document</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- submit_job-source -->
          
        </div>

        

        
      </div><!-- submit_job-method -->

    
      <div id="method-i-submit_job_doc" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">submit_job_doc</span><span
            class="method-args">(job_document)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Submit a job to be queued for execution on the server.</p>

<p>Return the URL to the job resource.</p>

<p>job_document – A job document created with <a
href="Client.html#method-i-create_job_doc">#create_job_doc</a>() specifying</p>

<pre>the workflow to run with which inputs.</pre>

<p>Raises:</p>

<pre>CouldNotCreateError -- If the service returned 200 OK instead of
        creating the resource</pre>
          

          
          <div class="method-source-code" id="submit_job_doc-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 421</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">submit_job_doc</span>(<span class="ruby-identifier">job_document</span>)
        <span class="ruby-identifier">jobsURL</span> = <span class="ruby-identifier">get_user_collection_url</span>(<span class="ruby-string">&quot;jobs&quot;</span>)
        <span class="ruby-identifier">upload_to_collection</span>(<span class="ruby-identifier">jobsURL</span>, <span class="ruby-identifier">job_document</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-constant">MIME_TYPES</span>[<span class="ruby-value">:rest</span>])    
<span class="ruby-keyword">end</span></pre>
          </div><!-- submit_job_doc-source -->
          
        </div>

        

        
      </div><!-- submit_job_doc-method -->

    
      <div id="method-i-upload_data" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">upload_data</span><span
            class="method-args">(hash)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Upload data to be used with <a
href="Client.html#method-i-submit_job">#submit_job</a>().</p>

<p>Return the URL to the created data resource.</p>

<p>hash – A hash where the keys are strings, matching the names of input</p>

<pre>ports of the workflow to run. The values can be strings, lists of strings, or deeper
lists.</pre>

<p>Raises:</p>

<pre>CouldNotCreateError -- If the service returned 200 OK instead of
        creating the resource</pre>
          

          
          <div class="method-source-code" id="upload_data-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 560</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">upload_data</span>(<span class="ruby-identifier">hash</span>)
        <span class="ruby-identifier">inputs</span> = <span class="ruby-identifier">create_data_doc</span>(<span class="ruby-identifier">hash</span>)
        <span class="ruby-identifier">upload_data_doc</span>(<span class="ruby-identifier">inputs</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- upload_data-source -->
          
        </div>

        

        
      </div><!-- upload_data-method -->

    
      <div id="method-i-upload_data_doc" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">upload_data_doc</span><span
            class="method-args">(xml_document)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Upload a data document to the current user’s collection.</p>

<p>Return the URL of the created data resource.</p>

<p>xml – A data document as a REXML::Document. This data document can be
created</p>

<pre>using create_data_doc()</pre>

<p>Raises:</p>

<pre>CouldNotCreateError -- If the service returned 200 OK instead of
        creating the resource</pre>
          

          
          <div class="method-source-code" id="upload_data_doc-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 330</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">upload_data_doc</span>(<span class="ruby-identifier">xml_document</span>)
        <span class="ruby-identifier">datas_url</span> = <span class="ruby-identifier">get_user_collection_url</span>(<span class="ruby-string">&quot;datas&quot;</span>)
        <span class="ruby-identifier">upload_to_collection</span>(<span class="ruby-identifier">datas_url</span>, <span class="ruby-identifier">xml_document</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-constant">MIME_TYPES</span>[<span class="ruby-value">:baclava</span>])
<span class="ruby-keyword">end</span></pre>
          </div><!-- upload_data_doc-source -->
          
        </div>

        

        
      </div><!-- upload_data_doc-method -->

    
      <div id="method-i-upload_to_collection" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">upload_to_collection</span><span
            class="method-args">(url, data, content_type)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Upload data by POST-ing to given URL.</p>

<p>Return the URL of the created resource if the request succeeded with 201
Created.</p>

<p>Raises:</p>

<pre>CouldNotCreateError -- If the service returned 200 OK instead of
        creating the resource
Net::HTTPError -- If any other HTTP result code (including errors) 
        was returned</pre>

<p>url – The URL of the collection of where to POST,</p>

<pre>normally retrieved using get_user_collection_url().</pre>

<p>data – The data to upload as a string</p>

<p>content_type – The MIME type of the data to upload. Typically the value</p>

<pre>of one of the MimeTypes constants. For data uploaded to the &quot;datas&quot; user 
collection this would be MIME_TYPES[:baclava], and for workflow to the &quot;
workflows&quot; collection, MIME_TYPES[:scufl]. Any other XML documents from 
the NAMESPACES[:service] namespace has the mime type MIME_TYPES[:rest]</pre>
          

          
          <div class="method-source-code" id="upload_to_collection-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 366</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">upload_to_collection</span>(<span class="ruby-identifier">url</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">content_type</span>)
        <span class="ruby-identifier">url</span> = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">url</span>)         
        <span class="ruby-identifier">request</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">Post</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">path</span>)
        <span class="ruby-identifier">request</span>.<span class="ruby-identifier">body</span> = <span class="ruby-identifier">data</span>
        <span class="ruby-identifier">request</span>[<span class="ruby-string">'Accept'</span>] = <span class="ruby-constant">MIME_TYPES</span>[<span class="ruby-value">:rest</span>]
        <span class="ruby-identifier">request</span>[<span class="ruby-string">'Content-Type'</span>] = <span class="ruby-identifier">content_type</span>
        <span class="ruby-identifier">request</span>.<span class="ruby-identifier">basic_auth</span> <span class="ruby-ivar">@username</span>, <span class="ruby-ivar">@password</span>
        <span class="ruby-identifier">response</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">start</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">host</span>, <span class="ruby-identifier">url</span>.<span class="ruby-identifier">port</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request</span>(<span class="ruby-identifier">request</span>)
        }
        <span class="ruby-identifier">response</span>.<span class="ruby-identifier">value</span>                       
        <span class="ruby-identifier">raise</span> <span class="ruby-constant">CouldNotCreateError</span>(<span class="ruby-identifier">url</span>, <span class="ruby-identifier">response</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTPCreated</span>)
        <span class="ruby-identifier">response</span>.<span class="ruby-identifier">header</span>[<span class="ruby-string">'Location'</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- upload_to_collection-source -->
          
        </div>

        

        
      </div><!-- upload_to_collection-method -->

    
      <div id="method-i-upload_workflow" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">upload_workflow</span><span
            class="method-args">(workflow_xml)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Upload a workflow XML document to the current users’ collection.</p>

<p>Return the URL of the created workflow resource.</p>

<p>workflow_xml – The Taverna scufl workflow as a string</p>

<p>Raises:</p>

<pre>CouldNotCreateError -- If the service returned 200 OK instead of
        creating the resource</pre>
          

          
          <div class="method-source-code" id="upload_workflow-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 592</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">upload_workflow</span>(<span class="ruby-identifier">workflow_xml</span>)
        <span class="ruby-identifier">workflows_url</span> = <span class="ruby-identifier">get_user_collection_url</span>(<span class="ruby-string">&quot;workflows&quot;</span>)
        <span class="ruby-identifier">upload_to_collection</span>(<span class="ruby-identifier">workflows_url</span>, <span class="ruby-identifier">workflow_xml</span>, <span class="ruby-constant">MIME_TYPES</span>[<span class="ruby-value">:scufl</span>])
<span class="ruby-keyword">end</span></pre>
          </div><!-- upload_workflow-source -->
          
        </div>

        

        
      </div><!-- upload_workflow-method -->

    
      <div id="method-i-url_valid-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">url_valid?</span><span
            class="method-args">(url)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tests if the url is valid for this server</p>
          

          
          <div class="method-source-code" id="url_valid-3F-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 336</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">url_valid?</span>(<span class="ruby-identifier">url</span>)
  <span class="ruby-identifier">url</span> = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">url</span>)
  <span class="ruby-identifier">req</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">Head</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">path</span>)
  <span class="ruby-identifier">req</span>.<span class="ruby-identifier">basic_auth</span> <span class="ruby-ivar">@username</span>, <span class="ruby-ivar">@password</span>
  <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">start</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">host</span>, <span class="ruby-identifier">url</span>.<span class="ruby-identifier">port</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request</span>(<span class="ruby-identifier">req</span>)
  }.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTPSuccess</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- url_valid-3F-source -->
          
        </div>

        

        
      </div><!-- url_valid-3F-method -->

    
      <div id="method-i-wait_for_job" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">wait_for_job</span><span
            class="method-args">(job_url, timeout=DEFAULT_TIMEOUT, refresh=DEFAULT_REFRESH)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Wait (blocking) for a job to finish, or until a maximum timeout  has been
reached.</p>

<p>Return the status of the job. If the</p>

<p>job_url – The URL to a job resource previously created using</p>

<pre>submit_job().</pre>

<p>timeout – The maximum number of seconds (as a float) to wait for job.</p>

<pre>The default value is DEFAULT_TIMEOUT.</pre>

<p>refresh – In seconds (as a float), how often to check the job’s</p>

<pre>status while waiting. The default value is DEFAULT_REFRESH.</pre>
          

          
          <div class="method-source-code" id="wait_for_job-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 610</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">wait_for_job</span>(<span class="ruby-identifier">job_url</span>, <span class="ruby-identifier">timeout</span>=<span class="ruby-constant">DEFAULT_TIMEOUT</span>, <span class="ruby-identifier">refresh</span>=<span class="ruby-constant">DEFAULT_REFRESH</span>)
        <span class="ruby-identifier">now</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
        <span class="ruby-identifier">_until</span> = <span class="ruby-identifier">now</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">timeout</span>
        <span class="ruby-keyword">while</span> <span class="ruby-identifier">_until</span> <span class="ruby-operator">&gt;</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">finished?</span>(<span class="ruby-identifier">job_url</span>)
                <span class="ruby-identifier">now</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span> <span class="ruby-comment"># finished?() might have taken a while</span>
                <span class="ruby-identifier">sleep</span> [[<span class="ruby-identifier">refresh</span>, <span class="ruby-identifier">_until</span><span class="ruby-operator">-</span><span class="ruby-identifier">now</span>].<span class="ruby-identifier">min</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">max</span>
                <span class="ruby-identifier">now</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span> <span class="ruby-comment"># after the sleep</span>
        <span class="ruby-keyword">end</span>         
        <span class="ruby-identifier">get_job_status</span>(<span class="ruby-identifier">job_url</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- wait_for_job-source -->
          
        </div>

        

        
      </div><!-- wait_for_job-method -->

    
      <div id="method-i-workflow_exists-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">workflow_exists?</span><span
            class="method-args">(workflow_url)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Checks if the workflow exists on the server</p>

<p>workflow_url – The URL to a workflow previously uploaded using</p>

<pre>upload_workflow().</pre>
          

          
          <div class="method-source-code" id="workflow_exists-3F-source">
            <pre><span class="ruby-comment"># File lib/enactor/client.rb, line 569</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">workflow_exists?</span>(<span class="ruby-identifier">workflow_url</span>)
        <span class="ruby-identifier">url_valid?</span>(<span class="ruby-identifier">workflow_url</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- workflow_exists-3F-source -->
          
        </div>

        

        
      </div><!-- workflow_exists-3F-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

